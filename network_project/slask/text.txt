#define MAX_LOGINDAT 16
 9 #define MAX_FILENAME 16
10
11 #define CLIENT 0
12 #define SAMPLE 1
13
14 typedef struct DBClient {
15   char username[MAX_LOGINDAT];
16   char password[MAX_LOGINDAT];
17   char *activity;
18 } dbcent_t;
19
20 typedef struct DBSample {
21   char *samples;
22 } dbsamp_t;
23
24 typedef struct DataBase {
25   char filename[MAX_FILENAME];
26   FILE *file_client;
27   FILE *file_sample;
28   dbcent_t **clients;
29   dbsamp_t *samples;
30 } base_t;

/*
static void table_cmods_dist(read_t *reader) {

  size_t cmod_index = 0;
  size_t memb_index = 0;

  char inbyte = ' '; 
  char number_buffer[6] = {0};

  for (size_t i = 0; i < reader->file_size; i++) {
    
    inbyte = reader->file_data[i];
    memb_index += (inbyte == DELIM) ? 1 : 0;

    switch(memb_index) {

    case MEMB_CMOD_ID:
      number_buffer[i] = inbyte;
      if (number_buffer[i] == DELIM) {
        number_buffer[i] = '\0';
        reader->model_cmods[cmod_index].id = atoi(number_buffer);
      }
      break;

    case MEMB_CMOD_UN:
      if (inbyte != DELIM)
        reader->model_cmods[cmod_index].username[i] = inbyte;
      else
        reader->model_cmods[cmod_index].username[i] = '\0';
      break;

    case MEMB_CMOD_PW:
      if (inbyte != DELIM)
        reader->model_cmods[cmod_index].password[i] = inbyte;
      else
        reader->model_cmods[cmod_index].password[i] = '\0';
      break;

    case TABLE_DONE:
      printf("model done\n");
      break;

    default:
      free_driver(reader);
      printf("something went south dst_data_cmods\n");
      exit(EXIT_FAILURE);
    }

    if (memb_index % INTERVAL_CM == 0) {
      memb_index = 0;
      cmod_index++;
    }
  }
  printf("\ntable done\n");
}
*/


/*-------------------------------------------------------------------------------------
                                                                               MEMORY
-------------------------------------------------------------------------------------*/

static void view_memory_alloc(view_t *view) {

  view->curr_view = (char**) malloc(ROWS * sizeof(char *));
  for (size_t i = 0; i < ROWS; i++)
    view->curr_view[i] = (char *) malloc(COLS * sizeof(char));
}

static void view_memory_free(view_t *view) {

  for (size_t i = 0; i < ROWS; i++)
    free(view->curr_view[i]);
  free(view->curr_view);
}

void memory_driver(uint8_t controller, view_t *view) {

  if (controller) view_memory_alloc(view);
  else view_memory_free(view);
}

/*-------------------------------------------------------------------------------------
                                                                               RENDER
-------------------------------------------------------------------------------------*/

static void clear_old_view(view_t *view) {

  for (size_t i = 0; i < ROWS; i++) {
    for (size_t j = 0; i < COLS; j++) {
      view->curr_view[i][j] = '\0';
    }
  }
}

static void draw_new_view(uint8_t controller, view_t *view) {

  for (size_t i = 0; i < ROWS; i++) {
    for (size_t j = 0; i < COLS; j++) {
      if (controller == 0)
        view->curr_view[i][j] = '#';
      else if (controller == 1)
        view->curr_view[i][j] = 'o';
      else
        view->curr_view[i][j] = '%';
    }
  }
}

void render_view(view_t *view) {


}

/*-------------------------------------------------------------------------------------
                                                                                 VIEW
-------------------------------------------------------------------------------------*/
/*
static void view_main_menu(cent_t *client) {
  printf("Here's main menu.\n");
}

static void view_resp_menu(cent_t *client) {
  printf("Here's response.\n");
}

static void view_rqst_menu(cent_t *client) {
  printf("Here's request.n\n");
}

typedef void (*view_func)(cent_t *client);

typedef struct {
  view_func func;
} view_item;

static view_item view_items[] = {
  {view_main_menu}, {view_resp_menu}, {view_rqst_menu}
};

void view_driver(cent_t *client) {
  view_items[client->view].func(client);
}
*/

#define READ_FILE 0     // as set, WRITE FILE as clear.
#define READ_CLIENT 1
#define READ_SAMPLE 2
#define WRITE_CLIENT 3
#define WRITE_SAMPLE 4

#define SUCCESS 5       // as set, FAILURE as clear.

#define byte_check(byte, bit) (byte &= (1 << bit))


static filed_item field_items[] = {
  {"ERROR FILE  --  failed to open file %s\n", open_file},
  {file_driver_fetch_rows},
  {file_driver_alloc_rows}
};

//---------------------------------------------------------------------------------------------------------error handeling
typedef uint8_t (*filed_func)(filed_t *driver);

typedef struct FileDriverError {
  const char *error_message;
  filed_func func;
} filed_item;

uint8_t server_assert(filed_item *item);'


typedef struct MModel {
  size_t id;
  char username[DBUFF];
  char topic[DBUFF];
  char datetime[TBUFF];
  char message[MBUFF];
} mmod_t;
//----------------------------------------------------------------------------------------------------------------------
typedef struct CModel {
  size_t id;
  char username[DBUFF];
  char password[DBUFF];
} cmod_t;
//----------------------------------------------------------------------------------------------------------------------
typedef struct SModel {
  size_t id;
  char temperature[DBUFF];
  char datetime[TBUFF];
} smod_t;
//----------------------------------------------------------------------------------------------------------------------
typedef struct RouteItem {
  uint8_t model;
  uint8_t membr;
  const char *file_path;
} route_item;
*/

/*
static const char *REQUEST_START[] = {
  "-fetch data", "-steer device", "-make comment", "-logout"
};
static const char *REQUEST_FETCH[] = {
  "-temp", "-back"
};
static const char *REQUEST_STEER[] = {
  "-red", "-blue", "-green", "-back"
};

static uint8_t MENU = START;
static size_t request_size = 0;

static int8_t request_scanner(char *request, const char *commands[], int8_t array_size) {

  request_size = scan_driver(request, MAX_BUFFER, "enter");

  for (int8_t cmp = 0; cmp < array_size; cmp++) {
    if (strcmp(request, commands[cmp]) == 0)
      return cmp;
  }
  printf("you've typed an invalid command, try again!\n\n");
  return - 1;
}

static int8_t request_start(char *request) {

  int8_t array_size = ARRAY_SIZE(REQUEST_START);
  int8_t choice = request_scanner(request, REQUEST_START, array_size);

  if (choice == - 1) {
    return START;
  } else if (choice == array_size - 1) {
    return LEAVE;
  } else {
    return choice + 1;
  }
}

static int8_t request_fetch(char *request) {

  int8_t array_size = ARRAY_SIZE(REQUEST_FETCH);
  int8_t choice = request_scanner(request, REQUEST_FETCH, array_size);

  if (choice == - 1 || choice == array_size - 1)
    return START;
  return LEAVE;
}

static int8_t request_steer(char *request) {

  int8_t array_size = ARRAY_SIZE(REQUEST_STEER);
  int8_t choice = request_scanner(request, REQUEST_STEER, array_size);

  if (choice == - 1 || choice == array_size - 1)
    return START;
  return LEAVE;
}
*/

size_t request_driver(char *request, uint8_t *online) {

  MENU = (!*online) ? command_driver(request, online) : START;

  while (MENU != LEAVE) {

	  switch(MENU) {
    
	  case START:
	    MENU = request_start(request);
	    break;

	  case FETCH:
	    MENU = request_fetch(request);
	    break;

	  case STEER:
	    MENU = request_steer(request);
	    break;

	  default:
	    printf("something isn't right.\n");
	    exit(EXIT_FAILURE);
	  }
  }

  return request_size;
}

#ifndef CLIENT_H_
#define CLIENT_H_

#include <stdint.h>
#include "clientconfigs.h"

typedef struct Client {
  uint8_t online;
  char request[RBUFF];
  char command[DBUFF];
  char username[DBUFF];
  char password[DBUFF];
} cent_t;

#endif

static uint8_t state_main(char *command) {
  printf("state main\n");
  return SUCC;
}

static state_item state_items[] = {
  {SCONN, state_connect},
  {SMAIN, state_main}
};

#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include "request.h"
#include "cstring.h"
#include "scan.h"
#include "command.h"


static const char *ACONN[] = {
  "-login", "-signup", "-exit"
};

static void command_print(const char *view, const char **options, uint8_t array_size) {
  Info_View_Print(view);

  for (uint8_t i = 0; i < array_size; i++)
    printf("\t\t%s\n", options[i]);
}

static int8_t command_check(char *command, const char **options, uint32_t cmnd_size, uint8_t array_size) {

  for (uint8_t i = 0; i < array_size; i++) {
    printf("command: %s\n", options[i]);
    if (string_comp(command, options[i], cmnd_size))
      return i;
  }
  printf("'%s' not an option, try again.\n");
  memset(command, '\0', DBUFF);
  return - 1;
}

static uint8_t command_scan(char **options) {

  uint8_t option = 0;
  uint32_t cmnd_size = 0;
  uint8_t state = SELECT;

  char command[DBUFF] = {'\0'};

  while (state != COMMIT) {
    
    switch(state) {

    case SELECT:
      cmnd_size = scan_driver(command, DBUFF, "select command: ");
      state = VERIFY;
      break;
    case VERIFY:
      option = command_check(command, options, cmnd_size, ARRAY_SIZE(ACONN));
      if (option < 0)
        state = SELECT;
      else
        state = COMMIT;
      break;
    default:
      printf("error message command_scan\n");
      exit(EXIT_FAILURE);
  }
  return option;
}

static uint8_t state_connect(char *command) {
  command_print(View_Connect, ACONN, ARRAY_SIZE(ACONN));
  command_scan(ACONN);
}

static state_item state_items[] = {
  {SCONN, state_connect}
};

uint8_t command_driver(char *request, uint8_t state) {
  
  char command[DBUFF] = {'\0'};
  return state_items[state].func(command);
}